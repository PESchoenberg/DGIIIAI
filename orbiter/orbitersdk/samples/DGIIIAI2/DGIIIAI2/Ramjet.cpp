// =============================================================================
//                ORBITER MODULE: DeltaGlider
//                  Part of the ORBITER SDK
//          Copyright (C) 2001-2003 Martin Schweiger
//                   All rights reserved
//
// Ramjet.cpp
// Implementation for the delta glider ramjet engine
// =============================================================================

#include "Ramjet.h"

/**
Constructor.
*/
Ramjet::Ramjet (VESSEL *_vessel): vessel(_vessel)
{
	nthdef = 0;    // No thrusters associated yet.
}

/**
Destructor.
*/
Ramjet::~Ramjet ()
{
	if (nthdef) 
	{  
		// Delete list of thruster definitions.
		for (UINT i = 0; i < nthdef; i++)
		{
			delete thdef[i];
		}
		delete []thdef;
	}
}

/**
Add a new thruster definition to the list of engines managed by the Ramjet object. Engine design 
parameters:

- Qr: Fuel heating value (FHV) [J/kg]. Value for typical jet fuel is about 4.5e7. Qr influences 
the rate at which fuel must be burned to obtain a given amount of thrust.

- Ai: Inlet cross section [m^2]. Ai basically scales the size of the engine, i.e. determines how 
much thrust it generates and how much fuel it burns.

- Tb_max: Maximum burner temperature [K] (due to material limits). Determines how much thrust 
can be generated without melting the engine, and up to what velocity the engine can be operated. 
A typical value may be around 2400K.	
*/
void Ramjet::AddThrusterDefinition (THRUSTER_HANDLE th,
	double Qr, double Ai, double Tb_max, double dmf_max)
{
	THDEF *thd   = new THDEF;
	thd->th      = th;
	thd->Qr      = Qr;
	thd->Ai      = Ai;
	thd->Tb_max  = Tb_max;
	thd->dmf_max = dmf_max;
	thd->dmf     = 0.0;
	thd->F       = 0.0;
	for (int i = 0; i < 3; i++) thd->T[i] = 0.0;

	THDEF **tmp = new THDEF*[nthdef+1];
	if (nthdef) 
	{
		memcpy (tmp, thdef, nthdef*sizeof (THDEF*));
		delete []thdef;
	}
	thdef = tmp;
	thdef[nthdef++] = thd;
}

/**
Calculates the thrust generated by each thruster and returns the force value in the supplied 
list F On input, F must point to an array of at least the same length as the number of thruster 
definitions (nthdef).
*/
void Ramjet::Thrust (double *F) const
{
	const OBJHANDLE hBody = vessel->GetAtmRef();
	const ATMCONST *atm = (hBody ? oapiGetPlanetAtmConstants (hBody) : 0);

	if (atm) 
	{ 
		// Atmospheric parameters available.
		
		double M, Fs, T0, Td, Tb, Tb0, Te, p0, pd, D, rho, cp, v0, ve, tr, lvl, dma, dmf, precov, dmafac;
		const double eps = 1e-4;
		const double dma_scale = 2.7e-4;

		M   = vessel->GetMachNumber();                     // Mach number.
		T0  = vessel->GetAtmTemperature();                 // Freestream temperature.
		p0  = vessel->GetAtmPressure();                    // Freestream pressure.
		rho = vessel->GetAtmDensity();                     // Freestream density.
		cp  = atm->gamma * atm->R / (atm->gamma-1.0);      // Specific heat (pressure).
		v0  = M * sqrt (atm->gamma * atm->R * T0);         // Freestream velocity.
		tr  = (1.0 + 0.5*(atm->gamma-1.0) * M*M);          // Temperature ratio.
		Td  = T0 * tr;                                     // Diffuser temperature.
		pd  = p0 * pow (Td/T0, atm->gamma/(atm->gamma-1.0)); // Diffuser pressure.
		precov = max (0.0, 1.0-0.075*pow (max(M,1.0)-1.0, 1.35)); // Pressure recovery.
		dmafac = dma_scale*precov*pd;

		for (UINT i = 0; i < nthdef; i++) 
		{
			Tb0 = thdef[i]->Tb_max;                        // Max burner temperature.
			if (Tb0 > Td) 
			{                                
				// We are within operational range.
				lvl  = vessel->GetThrusterLevel (thdef[i]->th); // Throttle level.
				D    = (Tb0-Td) / (thdef[i]->Qr/cp - Tb0); // Max fuel-to-air ratio (what if negative?).
				D   *= lvl;                                // Actual fuel-to-air ratio.

				dma = dmafac * thdef[i]->Ai;               // Air mass flow rate [kg/s].
				//dma  = rho * v0 * thdef[i]->Ai;            // Air mass flow rate.
				dmf  = D * dma;                            // Fuel mass flow rate.
				if (dmf > thdef[i]->dmf_max) 
				{             
					// Max fuel rate exceeded.
					dmf = thdef[i]->dmf_max;
					D = dmf/dma;
				}
				Tb   = (D*thdef[i]->Qr/cp + Td) / (1.0+D); // Actual burner temperature.
				Te   = Tb * pow (p0/pd, (atm->gamma-1.0)/atm->gamma); // Exhaust temperature.
				ve   = sqrt (2.0*cp*(Tb-Te));              // Exhaust velocity.
			    Fs  = (1.0+D)*ve - v0;                     // Specific thrust.
				thdef[i]->F = F[i] = max (0.0, Fs*dma);    // Thrust force.
				thdef[i]->dmf = dmf;
				thdef[i]->T[1] = Tb;
				thdef[i]->T[2] = Te;

			} 
			else 
			{                                       
				// Overheating!
				thdef[i]->F = F[i] = 0.0;
				thdef[i]->dmf = 0.0;
				thdef[i]->T[1] = thdef[i]->T[2] = Td;

			}
			thdef[i]->T[0] = Td;
		}

	} 
	else 
	{   
		// No atmospheric parameters.
		for (UINT i = 0; i < nthdef; i++) 
		{
			thdef[i]->F = F[i] = 0.0;
			thdef[i]->dmf = 0.0;
		}

	}
}

/**
Returns thrust-specific fuel consumption of thruster idx based on last thrust calculation.
*/
double Ramjet::TSFC (UINT idx) const
{
	const double eps = 1e-5;
	return thdef[idx]->dmf/(thdef[idx]->F+eps);
}
